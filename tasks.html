<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tasks - COSMIC Toolkit</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">COSMIC Toolkit</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="tasks"><a class="header" href="#tasks">Tasks</a></h1>
<p>Since the update function is called from the same event loop that renders the application and processes user inputs, the GUI will block for the duration that the application spends inside of the update function. To avoid blocking the GUI, any operation(s) other than what is necessary to update the model should placed into tasks.</p>
<pre><code class="language-rs">fn update(&amp;mut self, message: Self::Message) -&gt; cosmic::Task&lt;cosmic::Action&lt;Self::Message&gt;&gt; {
    cosmic::task::future(async move {
        Message::BuildResult(build().await)
    })
}
</code></pre>
<p><a href="https://pop-os.github.io/libcosmic/cosmic/iced_winit/runtime/struct.Task.html">Tasks</a> enable applications to execute operations asynchronously on background thread(s) without blocking the GUI. Returned as the output of the update function, they are spawned for concurrent execution on an async executor running on a background thread. Tasks based on <a href="https://doc.rust-lang.org/stable/std/future/trait.Future.html">futures</a> return their output as a message to the application upon completion. Whereas tasks based on <a href="https://pop-os.github.io/libcosmic/futures_core/stream/trait.Stream.html">streams</a> can stream messages to the application throughout their execution.</p>
<h2 id="avoid-blocking-the-async-executor"><a class="header" href="#avoid-blocking-the-async-executor">Avoid blocking the async executor</a></h2>
<p>However, for the same reason that the GUI blocks when an update function is executing, similar is true for the thread where the async executor is scheduling the execution of its futures. The default executor for COSMIC applications is a <a href="https://tokio.rs/">tokio</a> runtime configured to use a single background thread for scheduling async tasks. So if the application needs to spawn many futures on the runtime to execute concurrently, any operation that would block the executor should be moved onto another thread with <a href="https://docs.rs/tokio/latest/tokio/task/fn.spawn_blocking.html">tokio::task::spawn_blocking</a>.</p>
<pre><code class="language-rs">fn update(&amp;mut self, message: Self::Message) -&gt; cosmic::Task&lt;cosmic::Action&lt;Self::Message&gt;&gt; {
    match message {
        Message::WorkUnitReceived(work_unit) =&gt; {
            cosmic::task::future(async move {
                Message::WorkUnitResult(tokio::spawn_blocking(move || {
                    fold_protein("0x23", 110, 80, 19, work_unit)
                }).await)
            })
        }

        // ...
    }
}
</code></pre>
<h2 id="cosmic-actions"><a class="header" href="#cosmic-actions">COSMIC Actions</a></h2>
<p>The cosmic runtime has its own message type for handling updates to the cosmic runtime: <code>cosmic::app::Action</code>. To enable the cosmic runtime to handle messages simultaneously for itself and the application, the application's <code>Message</code> type is wrapped alongside <code>cosmic::app::Action</code> in the <code>cosmic::Action&lt;Message&gt;</code> type.</p>
<p>Since there are situations where applications may need to send messages to the cosmic runtime, all <code>Application</code> methods which return <code>Task</code>s are defined to return <code>cosmic::Task&lt;cosmic::Action&lt;Message&gt;&gt;</code>. This means that you may see a type error if you try to return a <code>cosmic::Task</code> directly with your application's <code>Message</code> type without mapping it <code>cosmic::Action::App</code> beforehand. The <code>cosmic::task</code> module contains functions which automatically convert application messages into <code>cosmic::Action&lt;Message&gt;</code>.</p>
<pre><code class="language-rs">fn update(&amp;mut self, message: Self::Message) -&gt; cosmic::Task&lt;cosmic::Action&lt;Self::Message&gt;&gt; {
    // Create a task that emits an application message without needing to await the value.
    let app_task = cosmic::Task::done(Message::ApplicationEvent)
        .map(cosmic::Action::from);

    // Create a cosmic action directly
    let show_window_menu = cosmic::Task::done(cosmic::app::Action::ShowWindowMenu)
        .map(cosmic::Action::from);

    // Use a helper from the ApplicationExt trait to create a cosmic task
    let set_window_title = self.set_window_title("Custom application title".into());

    cosmic::Task::batch(vec![app_task, show_window_menu, set_window_title])
}
</code></pre>
<h2 id="futures"><a class="header" href="#futures">Futures</a></h2>
<p>Tasks may be created from futures using <a href="future">cosmic::task::future</a>.</p>
<pre><code class="language-rs">fn update(&amp;mut self, message: Self::Message) -&gt; cosmic::Task&lt;cosmic::Action&lt;Self::Message&gt;&gt; {
    match message {
        Message::Clicked =&gt; {
            self.counter += 1;
            self.counter_text = format!("Clicked {} times", self.counter);

            // Await for 3 seconds in the background, and then request to decrease the counter.
            return cosmic::task::future(async move {
                tokio::time::sleep(Duration::from_millis(3000)).await;
                Message::Decrease
            });
        }

        Message::Decrease =&gt;  {
            self.counter -= 1;
            self.counter_text = format!("Clicked {} times", self.counter);
        }
    }

    Command::none()
}
</code></pre>
<h2 id="streaming"><a class="header" href="#streaming">Streaming</a></h2>
<p>Alternatively, they can produced from types which implement <a href="https://pop-os.github.io/libcosmic/futures_core/stream/trait.Stream.html">Stream</a>. Such as from the receiving end of a channel which it is being pushed to from anothre thread.</p>
<pre><code class="language-rs">fn update(&amp;mut self, message: Self::Message) -&gt; cosmic::Task&lt;cosmic::Action&lt;Self::Message&gt;&gt; {
    match message {
        Message::Start =&gt; {
            self.progress = Some(0);

            let (tx, rx) = tokio::sync::mpsc::unbounded_channel();

            std::thread::spawn(move || {
                std::thread::sleep(std::time::Duration::from_secs(3));
                _ = tx.send(Message::Progress(25));
                std::thread::sleep(std::time::Duration::from_secs(3));
                _ = tx.send(Message::Progress(50));
                std::thread::sleep(std::time::Duration::from_secs(3));
                _ = tx.send(Message::Progress(75));
                std::thread::sleep(std::time::Duration::from_secs(3));
                _ = tx.send(Message::Progress(100));
            });

            return cosmic::Task::stream(tokio_stream::wrappers::UnboundedReceiverStream(rx))
                // Must wrap our app type in `cosmic::Action`.
                .map(cosmic::Action::App);
        }

        Message::Progress(progress) =&gt; {
            self.progress = Some(progress);
        }
    }

    cosmic::Task::none()
}
</code></pre>
<h2 id="channel"><a class="header" href="#channel">Channel</a></h2>
<p>Streams can be created directly from a future with an async channel using <a href="https://pop-os.github.io/libcosmic/iced_futures/stream/fn.channel.html">cosmic::iced_futures::stream::channel</a>.
This is commonly used as an alternative to the lack of async generators in Rust.</p>
<pre><code class="language-rs">fn update(&amp;mut self, message: Self::Message) -&gt; cosmic::Task&lt;cosmic::Action&lt;Self::Message&gt;&gt; {
    match message {
        Message::Start =&gt; {
            self.progress = Some(0);

            return cosmic::Task::stream(cosmic::iced_futures::stream::channel(|tx| async move {
                tokio::time::sleep(std::time::Duration::from_secs(3)).await;
                _ = tx.send(Message::Progress(25)).await;
                tokio::time::sleep(std::time::Duration::from_secs(3)).await;
                _ = tx.send(Message::Progress(50)).await;
                tokio::time::sleep(std::time::Duration::from_secs(3)).await;
                _ = tx.send(Message::Progress(75)).await;
                tokio::time::sleep(std::time::Duration::from_secs(3)).await;
                _ = tx.send(Message::Progress(100)).await;
            }))
            // Must wrap our app type in `cosmic::Action`.
            .map(cosmic::Action::App);
        }

        Message::Progress(progress) =&gt; {
            self.progress = Some(progress);
        }
    }

    cosmic::Task::none()
}
</code></pre>
<h2 id="batches"><a class="header" href="#batches">Batches</a></h2>
<p>They can also be <a href="https://pop-os.github.io/libcosmic/cosmic/task/fn.batch.html">batched</a> for concurrent execution, where messages will be received in the order of completion.</p>
<pre><code class="language-rs">fn update(&amp;mut self, message: Self::Message) -&gt; cosmic::Task&lt;cosmic::Action&lt;Self::Message&gt;&gt; {
    match message {
        Message::BatchStarted =&gt; {
            eprintln!("started handling batch");
        }

        Message::Clicked =&gt; {
            self.counter += 1;
            self.counter_text = format!("Clicked {} times", self.counter);

            // Run two async tasks concurrently.
            return cosmic::task::batch(vec![
                // Await for 3 seconds in the background, and then request to decrease the counter.
                cosmic::task::future(async move {
                    tokio::time::sleep(Duration::from_millis(3000)).await;
                    Message::Decrease
                }),
                // Immediately returns a message without waiting.
                cosmic::task::message(Message::BatchStarted)
            ]);
        }

        Message::Decrease =&gt;  {
            self.counter -= 1;
            self.counter_text = format!("Clicked {} times", self.counter);
        }
    }

    Command::none()
}
</code></pre>
<h2 id="widget-operations"><a class="header" href="#widget-operations">Widget Operations</a></h2>
<p>They can also be used to perform an operation onto a widget, such as focusing a button or text input.</p>
<pre><code class="language-rs">return cosmic::widget::button::focus(self.BUTTON_ID);
</code></pre>
<h2 id="chaining"><a class="header" href="#chaining">Chaining</a></h2>
<p>If you need to configure multiple tasks for execution, where some tasks depend on the completion of another before they start, the <code>Task::chain</code> method can be used to allow the execution of one task to begin only after the first has finished.</p>
<pre><code class="language-rs">cosmic::task::future(async move { build().await })
    .chain(cosmic::task::future(async move { clean().await }))
</code></pre>
<h2 id="aborting"><a class="header" href="#aborting">Aborting</a></h2>
<p>This gives an abort handle to the application that you can store in your application to cancel a running task.</p>
<pre><code class="language-rs">let (task, abort_handle) = cosmic::task::future(async move {
    tokio::time::sleep(std::time::Duration::from_secs(3));
    println!("task finished");
    Message::Finished
}));

abort_handle.abort();
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="application-trait.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="subscriptions.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="application-trait.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="subscriptions.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
